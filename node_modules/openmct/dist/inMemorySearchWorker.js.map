{"version":3,"file":"inMemorySearchWorker.js","mappings":"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","sources":["webpack://openmct/webpack/universalModuleDefinition","webpack://openmct/./src/api/objects/InMemorySearchWorker.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"openmct\"] = factory();\n\telse\n\t\troot[\"openmct\"] = factory();\n})(this, () => {\nreturn ","/*****************************************************************************\n * Open MCT, Copyright (c) 2014-2023, United States Government\n * as represented by the Administrator of the National Aeronautics and Space\n * Administration. All rights reserved.\n *\n * Open MCT is licensed under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n * Open MCT includes source code licensed under additional open source\n * licenses. See the Open Source Licenses file (LICENSES.md) included with\n * this source code distribution or the Licensing information page available\n * at runtime from the About dialog for additional information.\n *****************************************************************************/\n\n/**\n * Module defining InMemorySearchWorker. Created by deeptailor on 10/03/2019.\n */\n(function () {\n  // An object composed of domain object IDs and models\n  // {id: domainObject's ID, name: domainObject's name}\n  const indexedDomainObjects = {};\n  const indexedAnnotationsByDomainObject = {};\n  const indexedAnnotationsByTag = {};\n\n  self.onconnect = function (e) {\n    const port = e.ports[0];\n\n    port.onmessage = function (event) {\n      const requestType = event.data.request;\n      if (requestType === 'index') {\n        indexItem(event.data.keyString, event.data.model);\n      } else if (requestType === 'OBJECTS') {\n        port.postMessage(searchForObjects(event.data));\n      } else if (requestType === 'ANNOTATIONS') {\n        port.postMessage(searchForAnnotations(event.data));\n      } else if (requestType === 'TAGS') {\n        port.postMessage(searchForTags(event.data));\n      } else {\n        throw new Error(`Unknown request ${event.data.request}`);\n      }\n    };\n\n    port.start();\n  };\n\n  self.onerror = function (error) {\n    //do nothing\n    console.error('Error on feed', error);\n  };\n\n  function indexAnnotation(objectToIndex, model) {\n    model.targets.forEach((target) => {\n      const targetID = target.keyString;\n      if (!indexedAnnotationsByDomainObject[targetID]) {\n        indexedAnnotationsByDomainObject[targetID] = [];\n      }\n\n      objectToIndex.targets = model.targets;\n      objectToIndex.tags = model.tags;\n      const existsInIndex = indexedAnnotationsByDomainObject[targetID].some((indexedObject) => {\n        return indexedObject.keyString === objectToIndex.keyString;\n      });\n\n      if (!existsInIndex) {\n        indexedAnnotationsByDomainObject[targetID].push(objectToIndex);\n      }\n    });\n  }\n\n  function indexTags(keyString, objectToIndex, model) {\n    // add new tags\n    model.tags.forEach((tagID) => {\n      if (!indexedAnnotationsByTag[tagID]) {\n        indexedAnnotationsByTag[tagID] = [];\n      }\n\n      const existsInIndex = indexedAnnotationsByTag[tagID].some((indexedObject) => {\n        return indexedObject.keyString === objectToIndex.keyString;\n      });\n\n      if (!existsInIndex) {\n        indexedAnnotationsByTag[tagID].push(objectToIndex);\n      }\n    });\n    // remove old tags\n    const tagsToRemoveFromIndex = Object.keys(indexedAnnotationsByTag).filter((indexedTag) => {\n      return !model.tags.includes(indexedTag);\n    });\n    tagsToRemoveFromIndex.forEach((tagToRemoveFromIndex) => {\n      indexedAnnotationsByTag[tagToRemoveFromIndex] = indexedAnnotationsByTag[\n        tagToRemoveFromIndex\n      ].filter((indexedAnnotation) => {\n        const shouldKeep = indexedAnnotation.keyString !== keyString;\n\n        return shouldKeep;\n      });\n    });\n  }\n\n  function indexItem(keyString, model) {\n    const objectToIndex = {\n      type: model.type,\n      name: model.name,\n      keyString\n    };\n    if (model && model.type === 'annotation') {\n      if (model.targets) {\n        indexAnnotation(objectToIndex, model);\n      }\n\n      if (model.tags) {\n        indexTags(keyString, objectToIndex, model);\n      }\n    } else {\n      indexedDomainObjects[keyString] = objectToIndex;\n    }\n  }\n\n  /**\n   * Gets search results from the indexedItems based on provided search\n   *   input. Returns matching results from indexedItems\n   *\n   * @param data An object which contains:\n   *           * input: The original string which we are searching with\n   *           * maxResults: The maximum number of search results desired\n   *           * queryId: an id identifying this query, will be returned.\n   */\n  function searchForObjects(data) {\n    let results = [];\n    const input = data.input.trim().toLowerCase();\n    const message = {\n      request: 'searchForObjects',\n      results: [],\n      total: 0,\n      queryId: data.queryId\n    };\n\n    results =\n      Object.values(indexedDomainObjects).filter((indexedItem) => {\n        return indexedItem.name.toLowerCase().includes(input);\n      }) || [];\n\n    message.total = results.length;\n    message.results = results.slice(0, data.maxResults);\n\n    return message;\n  }\n\n  function searchForAnnotations(data) {\n    let results = [];\n    const message = {\n      request: 'searchForAnnotations',\n      results: [],\n      total: 0,\n      queryId: data.queryId\n    };\n\n    results = indexedAnnotationsByDomainObject[data.input] || [];\n\n    message.total = results.length;\n    message.results = results.slice(0, data.maxResults);\n\n    return message;\n  }\n\n  function searchForTags(data) {\n    let results = [];\n    const message = {\n      request: 'searchForTags',\n      results: [],\n      total: 0,\n      queryId: data.queryId\n    };\n\n    if (data.input) {\n      data.input.forEach((matchingTag) => {\n        const matchingAnnotations = indexedAnnotationsByTag[matchingTag];\n        if (matchingAnnotations) {\n          matchingAnnotations.forEach((matchingAnnotation) => {\n            const existsInResults = results.some((indexedObject) => {\n              return matchingAnnotation.keyString === indexedObject.keyString;\n            });\n            if (!existsInResults) {\n              results.push(matchingAnnotation);\n            }\n          });\n        }\n      });\n    }\n\n    message.total = results.length;\n    message.results = results.slice(0, data.maxResults);\n\n    return message;\n  }\n})();\n"],"names":["root","factory","exports","module","define","amd","this","indexedDomainObjects","indexedAnnotationsByDomainObject","indexedAnnotationsByTag","self","onconnect","e","port","ports","onmessage","event","requestType","data","request","keyString","model","objectToIndex","type","name","targets","forEach","target","targetID","tags","some","indexedObject","push","indexAnnotation","tagID","Object","keys","filter","indexedTag","includes","tagToRemoveFromIndex","indexedAnnotation","indexTags","indexItem","postMessage","results","input","trim","toLowerCase","message","total","queryId","values","indexedItem","length","slice","maxResults","searchForObjects","searchForAnnotations","Error","matchingTag","matchingAnnotations","matchingAnnotation","searchForTags","start","onerror","error","console"],"sourceRoot":""}